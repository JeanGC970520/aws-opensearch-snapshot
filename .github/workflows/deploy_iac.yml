name: Deploy AWS Infrastructure with CloudFormation

on:
  push:
    branches:
      - main
    paths:
      - 'cloudformation/**'  # Solo ejecutar cuando cambien los templates
      - '.github/workflows/**'
  pull_request:
    branches:
      - main
    paths:
      - 'cloudformation/**'
  workflow_dispatch:  # Permite ejecuci√≥n manual

env:
  AWS_REGION: us-east-1  # Cambia por tu regi√≥n
  SECRET_MANAGER_STACK_NAME: Stack-secret-manager
  OPENSEARCH_STACK_NAME: Stack-OpenSearch
  S3_STACK_NAME: Stack-s3
  LAMBDA_STACK_NAME: Stack-Lambda

jobs:
  validate-templates:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4  # Versi√≥n m√°s reciente
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4  # Versi√≥n actualizada
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Validation

      - name: Validate Secret Manager template
        run: |
          aws cloudformation validate-template \
            --template-body file://cloudformation/Stack-secret-manager.yml

      - name: Validate OpenSearch template
        run: |
          aws cloudformation validate-template \
            --template-body file://cloudformation/Stack-OpenSearch.yml

      - name: Validate S3 template
        run: |
          aws cloudformation validate-template \
            --template-body file://cloudformation/Stack-s3.yml
            
      - name: Validate Lambda template
        run: |
          aws cloudformation validate-template \
            --template-body file://cloudformation/Stack-Lambda.yml

  deploy-infrastructure:
    runs-on: ubuntu-latest
    needs: validate-templates
    permissions:
      id-token: write
      contents: read
    
    # Solo deployar en main, no en PRs
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActionsRole
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Deploy

      # Secrets Manager
      - name: Deploy Secrets Manager Stack
        uses: aws-actions/aws-cloudformation-github-deploy@v1
        with:
          name: ${{ env.SECRET_MANAGER_STACK_NAME }}
          template: cloudformation/Stack-secret-manager.yml
          no-fail-on-empty-changeset: "1"
          capabilities: CAPABILITY_IAM
          tags: |
            Environment=production
            Project=opensearch-lambda
            ManagedBy=github-actions

      # Put value on Secret Manager
      - name: Check secret about master user info
        id: opensearch_info
        run: |
          ARN_SECRET=$(aws secretsmanager list-secrets \
            --query "SecretList[?contains(Name, 'OPENSEARCH_MASTER_USER')].ARN" \
            --output text)

          echo "ARN_SECRET -> $ARN_SECRET"
    
          # Verificar que se obtuvo un ARN
          if [ -z "$ARN_SECRET" ]; then
            echo "Error: No se encontr√≥ ning√∫n secreto que contenga 'OPENSEARCH_MASTER_USER'"
            exit 1
          fi
          
          # Obtener informaci√≥n del secreto usando el ARN (sin comillas simples)
          SECRET_VALUE_OUT=$(aws secretsmanager describe-secret \
            --secret-id "$ARN_SECRET" \
            --output json)
          
          echo "SECRET_INFO:"
          echo "$SECRET_VALUE_OUT"

          # Exportar el JSON completo (escapando caracteres especiales)
          echo "secret_info<<EOF" >> $GITHUB_OUTPUT
          echo "$SECRET_VALUE_OUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "secret_arn=$ARN_SECRET" >> $GITHUB_OUTPUT

      - name: Debug Output
        run: |
          echo "=== Contenido completo ==="
          echo '${{ steps.opensearch_info.outputs.secret_info }}'
          echo "=== Fin contenido ==="

          SECRET_JSON='${{ steps.opensearch_info.outputs.secret_info }}'
    
          # Verificar que no est√© vac√≠o
          if [ -z "$SECRET_JSON" ]; then
            echo "‚ùå ERROR: secret_info output is empty"
            exit 1
          fi
          
          # Verificar que sea JSON v√°lido
          echo "$SECRET_JSON" | jq . > /dev/null || {
            echo "‚ùå ERROR: secret_info is not valid JSON"
            echo "Content received: $SECRET_JSON"
            exit 1
          }

      - name: Generate secure password
        id: secure_password
        run: |
          python3 << 'EOF'
          import random
          import string
          import os
          
          lowercase = string.ascii_lowercase
          uppercase = string.ascii_uppercase
          digits = string.digits
          special = "!@#$%^&*()-_=+"
          
          password = [
              random.choice(lowercase),
              random.choice(uppercase),
              random.choice(digits),
              random.choice(special)
          ]
          
          all_chars = lowercase + uppercase + digits + special
          for _ in range(8):
              password.append(random.choice(all_chars))
          
          random.shuffle(password)
          final_password = ''.join(password)
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f'password={final_password}\n')
          EOF

      - name: Store master user info
        uses: ./.github/actions/set_secret
        with:
          secret-arn: ${{ steps.opensearch_info.outputs.secret_arn }}
          secret-content: |
            {
              "username": "OpenSearhUserMaster",
              "password": "${{ steps.secure_password.outputs.password }}"
            }
          secret-name: 'OPENSEARCH_MASTER_USER'
        if: ${{ !contains(fromJSON(steps.opensearch_info.outputs.secret_info), 'AWSCURRENT') }}
      
      # Obtener informaci√≥n de VPC y subnets por defecto
      - name: Get default VPC info
        id: vpc-info
        run: |
          DEFAULT_VPC=$(aws ec2 describe-vpcs \
            --filters "Name=is-default,Values=true" \
            --query 'Vpcs[0].VpcId' \
            --output text)
          
          VPC_CIDR=$(aws ec2 describe-vpcs \
            --vpc-ids $DEFAULT_VPC \
            --query 'Vpcs[0].CidrBlock' \
            --output text)
          
          SUBNET_IDS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$DEFAULT_VPC" \
            --query 'Subnets[?MapPublicIpOnLaunch==`false`].[SubnetId]' \
            --output text | tr '\n' ',' | sed 's/,$//')
            
          # Si no hay subnets privadas, usar las p√∫blicas
          if [ -z "$SUBNET_IDS" ]; then
            SUBNET_IDS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$DEFAULT_VPC" \
              --query 'Subnets[0:1].SubnetId' \
              --output text | tr '\t' ',')
          fi
          
          # Validar que tenemos subnets
          if [ -z "$SUBNET_IDS" ] || [ "$SUBNET_IDS" = "None" ]; then
            echo "‚ùå Error: No se encontraron subnets en la VPC $DEFAULT_VPC"
            exit 1
          fi
          
          # Contar subnets
          SUBNET_COUNT=$(echo $SUBNET_IDS | tr ',' '\n' | wc -l)
          if [ $SUBNET_COUNT -lt 1 ]; then
            echo "‚ùå Error: Se necesitan al menos 1 subnets, encontradas: $SUBNET_COUNT"
            exit 1
          fi
          
          echo "vpc-id=$DEFAULT_VPC" >> $GITHUB_OUTPUT
          echo "vpc-cidr=$VPC_CIDR" >> $GITHUB_OUTPUT
          echo "subnet-ids=$SUBNET_IDS" >> $GITHUB_OUTPUT
          
          echo "üîç Using VPC: $DEFAULT_VPC"
          echo "üîç Using VPC CIDR: $VPC_CIDR"
          echo "üîç Using Subnets: $SUBNET_IDS (Count: $SUBNET_COUNT)"

      # Deploy OpenSearch first
      - name: Deploy OpenSearch Stack
        uses: aws-actions/aws-cloudformation-github-deploy@v1
        with:
          name: ${{ env.OPENSEARCH_STACK_NAME }}
          template: cloudformation/Stack-OpenSearch.yml
          no-fail-on-empty-changeset: "1"
          parameter-overrides: >-
            VPCId=${{ steps.vpc-info.outputs.vpc-id }},
            SubnetIds="${{ steps.vpc-info.outputs.subnet-ids }}",
            DomainName='my-opensearch'
          capabilities: CAPABILITY_IAM
          tags: |
            Environment=production
            Project=opensearch-lambda
            ManagedBy=github-actions

      # Wait for OpenSearch to be ready
      - name: Wait for OpenSearch deployment
        run: |
          echo "‚è≥ Waiting for OpenSearch stack to complete..."
          aws cloudformation wait stack-create-complete \
            --stack-name ${{ env.OPENSEARCH_STACK_NAME }} || \
          aws cloudformation wait stack-update-complete \
            --stack-name ${{ env.OPENSEARCH_STACK_NAME }}
          echo "‚úÖ OpenSearch stack is ready"

      # Deploy S3 bucket
      - name: Deploy S3 Stack
        uses: aws-actions/aws-cloudformation-github-deploy@v1
        with:
          name: ${{ env.S3_STACK_NAME }}
          template: cloudformation/Stack-s3.yml
          no-fail-on-empty-changeset: "1"
          capabilities: CAPABILITY_IAM
          tags: |
            Environment=production
            Project=opensearch-lambda
            ManagedBy=github-actions

      # Deploy Lambda stack
      - name: Deploy Lambda Stack
        uses: aws-actions/aws-cloudformation-github-deploy@v1
        with:
          name: ${{ env.LAMBDA_STACK_NAME }}
          template: cloudformation/Stack-Lambda.yml
          no-fail-on-empty-changeset: "1"
          parameter-overrides: >-
            VPCId=${{ steps.vpc-info.outputs.vpc-id }},
            SubnetIds="${{ steps.vpc-info.outputs.subnet-ids }}",
            FunctionName='opensearch-lambda'
          capabilities: CAPABILITY_IAM
          tags: |
            Environment=production
            Project=opensearch-lambda
            ManagedBy=github-actions
            
      # Test the deployment
      - name: Test Lambda function
        run: |
          echo "üß™ Testing Lambda function..."
          FUNCTION_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.LAMBDA_STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`LambdaArn`].OutputValue' \
            --output text | cut -d':' -f7)
            
          aws lambda invoke \
            --function-name $FUNCTION_NAME \
            --payload '{"action": "list"}' \
            response.json
            
          echo "üìÑ Lambda response:"
          cat response.json
          
      # Output important information
      - name: Show deployment info
        run: |
          echo "üéâ Deployment completed successfully!"
          echo "üìã Stack Information:"
          
          OPENSEARCH_ENDPOINT=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.OPENSEARCH_STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`OpenSearchEndpoint`].OutputValue' \
            --output text)
            
          LAMBDA_ARN=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.LAMBDA_STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`LambdaArn`].OutputValue' \
            --output text)
            
          echo "üîç OpenSearch Endpoint: $OPENSEARCH_ENDPOINT"
          echo "‚ö° Lambda ARN: $LAMBDA_ARN"
          
          # Save to GitHub summary
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| OpenSearch Endpoint | \`$OPENSEARCH_ENDPOINT\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Lambda ARN | \`$LAMBDA_ARN\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment Time | $(date) |" >> $GITHUB_STEP_SUMMARY